<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Self-Learning Chess AI</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
    #board {
      width: 100vw;
      height: 100vh;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard.min.css" />
</head>
<body>
  <div id="board"></div>
  <script>
    const game = new Chess();
    let qTable = JSON.parse(localStorage.getItem("chessAI_qTable") || "{}");

    function saveQTable() {
      localStorage.setItem("chessAI_qTable", JSON.stringify(qTable));
    }

    function learnFromMove(prevFen, move, reward) {
      if (!qTable[prevFen]) qTable[prevFen] = {};
      if (!qTable[prevFen][move]) qTable[prevFen][move] = 0;
      qTable[prevFen][move] += reward;
      saveQTable();
    }

    function getBestMove(fen) {
      const legalMoves = game.moves();
      if (!qTable[fen]) return legalMoves[Math.floor(Math.random() * legalMoves.length)];
      let best = legalMoves[0];
      let bestScore = qTable[fen][best] || 0;
      for (let move of legalMoves) {
        const score = qTable[fen][move] || 0;
        if (score > bestScore) {
          best = move;
          bestScore = score;
        }
      }
      return best;
    }

    const board = Chessboard('board', {
      draggable: true,
      position: 'start',
      onDragStart: (source, piece) => {
        if (game.game_over() || piece.search(/^b/) !== -1) return false;
        const legalMoves = game.moves({ square: source, verbose: true }).map(m => m.to);
        board.set({
          onSnapEnd: () => {},
          moveStart: source,
          moveEnd: (target) => {
            if (!legalMoves.includes(target)) return false;
            const move = game.move({ from: source, to: target, promotion: 'q' });
            board.position(game.fen());
            setTimeout(makeAIMove, 250);
            return true;
          }
        });
      },
      onDrop: (source, target) => {
        const move = game.move({ from: source, to: target, promotion: 'q' });
        if (move === null) return 'snapback';
        board.position(game.fen());
        setTimeout(makeAIMove, 250);
      }
    });

    function makeAIMove() {
      if (game.game_over()) return;
      const fen = game.fen();
      const move = getBestMove(fen);
      const moveObj = game.move(move);
      board.position(game.fen());
      learnFromMove(fen, move, 1);
    }
  </script>
</body>
</html>

